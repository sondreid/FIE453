}
always_0_stocks <- select_stocks_always_0(test_df)
select_stocks_always_0 <- function(test_df) {
#' @description:         Function that selects stocks based on predictability
#'                       with their performance metrics
#'
#' @param test_df        Passing a test data frame
#' @return               Companies with highest predictability
companies <- test_df$permno %>% unique()
#test_df  %<>% left_join(company_names_df, by = "permno") # merge with company names
company_predictability <- tibble()
for (company in companies) {
company_data <- test_df %>%
filter(permno == company)
company_predictions <- predict(rep(0, nrow(company_data)), company_data)
company_performance_metrics <- postResample(pred = rep(0, nrow(company_data)),
obs = test_df$retx)
company_predictability %<>% bind_rows(
tibble("Company name"       = get_company_name(company_data$permno[1]),
"Company identifier" = company_data$permno[1],
"Test RMSE"          = company_performance_metrics[[1]],
"Test MAE"           = company_performance_metrics[[3]])
)
}
return (company_predictability)
}
always_0_stocks <- select_stocks_always_0(test_df)
select_stocks <- function(test_df, selected_model) {
#' @description:         Function that selects stocks based on predictability
#'                       with their performance metrics
#'
#' @param test_df        Passing a test data frame
#' @param selected_model Passing a selected model
#' @return               Companies with highest predictability
companies <- test_df$permno %>% unique()
#test_df  %<>% left_join(company_names_df, by = "permno") # merge with company names
company_predictability <- tibble()
for (company in companies) {
company_data <- test_df %>%
filter(permno == company)
company_predictions <- predict(selected_model, company_data)
company_performance_metrics <- postResample(pred = company_predictions,
obs = company_data$retx)
company_predictability %<>% bind_rows(
tibble("Company name"       = get_company_name(company_data$permno[1]),
"Company identifier" = company_data$permno[1],
"Test RMSE"          = company_performance_metrics[[1]],
"Test MAE"           = company_performance_metrics[[3]])
)
}
return (company_predictability)
}
select_stocks <- function(test_df, selected_model) {
#' @description:         Function that selects stocks based on predictability
#'                       with their performance metrics
#'
#' @param test_df        Passing a test data frame
#' @param selected_model Passing a selected model
#' @return               Companies with highest predictability
companies <- test_df$permno %>% unique()
#test_df  %<>% left_join(company_names_df, by = "permno") # merge with company names
company_predictability <- tibble()
for (company in companies) {
company_data <- test_df %>%
filter(permno == company)
company_predictions <- predict(selected_model, company_data)
company_performance_metrics <- postResample(pred = company_predictions,
obs = company_data$retx)
company_predictability %<>% bind_rows(
tibble("Company name"       = get_company_name(company_data$permno[1]),
"Company identifier" = company_data$permno[1],
"Test RMSE"          = company_performance_metrics[[1]],
"Test MAE"           = company_performance_metrics[[3]])
)
}
return (company_predictability)
}
selected_stocks <- select_stocks(test_df, selected_model) %>%  arrange(`Test MAE`)
selected_stocks
always_0_stocks <- select_stocks_always_0(test_df)
select_stocks_always_0 <- function(test_df) {
#' @description:         Function that selects stocks based on predictability
#'                       with their performance metrics
#'
#' @param test_df        Passing a test data frame
#' @return               Companies with highest predictability
companies <- test_df$permno %>% unique()
#test_df  %<>% left_join(company_names_df, by = "permno") # merge with company names
company_predictability <- tibble()
for (company in companies) {
company_data <- test_df %>%
filter(permno == company)
company_performance_metrics <- postResample(pred = rep(0, nrow(company_data)),
obs = test_df$retx)
company_predictability %<>% bind_rows(
tibble("Company name"       = get_company_name(company_data$permno[1]),
"Company identifier" = company_data$permno[1],
"Test RMSE"          = company_performance_metrics[[1]],
"Test MAE"           = company_performance_metrics[[3]])
)
}
return (company_predictability)
}
always_0_stocks <- select_stocks_always_0(test_df)
always_0_stocks
select_stocks_always_0 <- function(test_df) {
#' @description:         Function that selects stocks based on predictability
#'                       with their performance metrics
#'
#' @param test_df        Passing a test data frame
#' @return               Companies with highest predictability
companies <- test_df$permno %>% unique()
company_predictability <- tibble()
for (company in companies) {
company_data <- test_df %>%
filter(permno == company)
company_performance_metrics <- postResample(pred = rep(0, nrow(company_data)),
obs = company_data$retx)
company_predictability %<>% bind_rows(
tibble("Company name"       = get_company_name(company_data$permno[1]),
"Company identifier" = company_data$permno[1],
"Test RMSE"          = company_performance_metrics[[1]],
"Test MAE"           = company_performance_metrics[[3]])
)
}
return (company_predictability)
}
always_0_stocks <- select_stocks_always_0(test_df)
always_0_stocks
always_0_stocks %>% arrange(`Test MAE`)
selected_stocks  %>% arrange(`Test MAE`)
View(selected_stocks)
View(selected_stocks)
View(always_0_stocks)
benchmark_0_results <- postResample(rep(0, nrow(test_df)), test_df$retx)
tibble("Test MAE" = benchmark_0_results[[3]],
"Model" = "0 return prediction") %>%
kable(caption = "Performance of 0-prediction model",
digits  = 4) %>%
kable_classic(full_width = F,
html_font  = "Times New Roman")
select_stocks <- function(test_df, selected_model) {
#' @description:         Function that selects stocks based on predictability
#'                       with their performance metrics
#'
#' @param test_df        Passing a test data frame
#' @param selected_model Passing a selected model
#' @return               Companies with highest predictability
companies <- test_df$permno %>% unique()
company_predictability <- tibble()
for (company in companies) {
company_data <- test_df %>%
filter(permno == company)
company_predictions <- predict(selected_model, company_data)
company_performance_metrics <- postResample(pred = company_predictions,
obs = company_data$retx)
company_predictability %<>% bind_rows(
tibble("Company name"       = get_company_name(company_data$permno[1]),
"Company identifier" = company_data$permno[1],
"Test RMSE"          = company_performance_metrics[[1]],
"Test MAE"           = company_performance_metrics[[3]])
)
}
return (company_predictability)
}
select_stocks_always_0 <- function(test_df) {
#' @description:         Function that selects stocks based on predictability
#'                       with their performance metrics
#'
#' @param test_df        Passing a test data frame
#' @return               Companies with highest predictability
companies <- test_df$permno %>% unique()
company_predictability <- tibble()
for (company in companies) {
company_data <- test_df %>%
filter(permno == company)
company_performance_metrics <- postResample(pred = rep(0, nrow(company_data)),
obs = company_data$retx)
company_predictability %<>% bind_rows(
tibble("Company name"       = get_company_name(company_data$permno[1]),
"Company identifier" = company_data$permno[1],
"Test RMSE"          = company_performance_metrics[[1]],
"Test MAE"           = company_performance_metrics[[3]])
)
}
return (company_predictability)
}
selected_stock_company_info(selected_stocks, test_df, 10) %>%
kable(caption = "10 stocks of highest predictability",
digits  = 2)  %>%
kable_classic(full_width = F,
html_font = "Times New Roman")
selected_stock_company_info(selected_stocks, test_df, 10) %>%
kable(caption = "10 stocks of highest predictability",
digits  = 2)  %>%
kable_classic(full_width = F,
html_font = "Times New Roman") %>%
save_kable("images/predictable_stocks.png",
zoom = 1.5,
density = 1900)
benchmark_0_results <- postResample(rep(0, nrow(test_df)), test_df$retx)
tibble("Test MAE" = benchmark_0_results[[3]],
"Model" = "0 return prediction") %>%
kable(caption = "Performance of 0-prediction model",
digits  = 4) %>%
kable_classic(full_width = F,
html_font  = "Times New Roman") %>%
save_kable("images/0_return_prediction.png",
zoom = 1.5,
density = 1900)
tibble("Test MAE" = benchmark_0_results[[3]],
"Model" = "0 return prediction") %>%
kable(caption = "Performance of 0-prediction model",
digits  = 4) %>%
kable_classic(full_width = F,
html_font  = "Times New Roman") %>%
save_kable("images/0_return_prediction.png",
zoom = 1.5,
density = 3000)
tibble("Test MAE" = benchmark_0_results[[3]],
"Model" = "0 return prediction") %>%
kable(caption = "Performance of 0-prediction model",
digits  = 4) %>%
kable_classic(full_width = F,
html_font  = "Times New Roman") %>%
save_kable("images/0_return_prediction.png",
zoom = 3,
density = 3000)
tibble("Test MAE" = benchmark_0_results[[3]],
"Model" = "0 return prediction") %>%
kable(caption = "Performance of 0-prediction model",
digits  = 4) %>%
kable_classic(full_width = F,
html_font  = "Times New Roman") %>%
save_kable("images/0_return_prediction.png",
zoom = 3,
density = 1500)
################################################################################
########################### Pre-processing #####################################
################################################################################
# Candidates:
# Libraries --------------------------------------------------------------------
library(tidyverse)
library(magrittr)
library(tidymodels)
library(randomForest)
library(caret)
library(doParallel)
library(MLmetrics)
library(gbm)
library(PerformanceAnalytics)
library(kableExtra)
library(knitr)
library(monomvn)
library(kableExtra)
library(lubridate)
library(kknn)
#library(RSNNS)
library(nnet)
# Set WD -----------------------------------------------------------------------
#setwd("~/OneDrive - Norges HandelshÃ¸yskole/MASTER/FIE453/FinalExam/FIE453/Final Paper")
# Load and read data -----------------------------------------------------------
load("data/merged.Rdata")
company_names_df <- read.csv(file = "descriptions/names.csv")
feature_names_df <- read.delim(file = "descriptions/compustat-fields.txt")
company_names_df %<>% rename_with(tolower) %>% mutate(date = ymd(date))
feature_names_df %<>% rename_with(tolower)
merged %<>% rename_with(tolower)
get_company_name <- function(input_permno) {
#'
#'@description: Returns the name of a company based on its company identification number
company_name <- company_names_df %>%
filter(permno == input_permno)
# If several names are registered. Pick the most recent
company_name %<>% arrange(desc(date))
return( company_name$comnam[1])
}
## Variables that cannot be inclduded with dependent variable RETX
# Irrelevant features ----------------------------------------------------------
# Variables that cannot be included with dependent variable RETX
excluded_variables <- c("ret",
"prc",         # Price should maybe be allowed
"vwretd",      # vwretd: market excess return
"datadate",
"date",        # Remove all date related variables
"datafqtr",
"fyearq",
"fyr",
"fqtr",
"datacqtr")
merged %<>% dplyr::select(-excluded_variables)
# Data reduction ---------------------------------------------------------------
get_subset_of_companies <-function(df, number_of_companies) {
#' @description:              To reduce run time, we want to reduce the
#'                            number of companies,(for variable selection
#'                            purposes)
#'
#' @param df                  The dataframe to be split
#' @param number_of_companies The number of speakers to be retained
#' @return                    A dataframe of fewer companies
set.seed(123)
companies <- df$permno %>% unique()
subset_of_companies <- companies %>%
sample(x = ., size = number_of_companies)
return(df %>% filter(permno %in% subset_of_companies))
}
get_subset_of_companies_ratio <-function(df, ratio) {
#' @Description:              To reduce run time, we want to reduce the
#'                            number of companies, (for variable selection
#'                            purposes)
#'
#' @param df                  The dataframe to be split
#' @param number_of_companies The number of speakers to be retained
#' @return:                   A dataframe of fewer companies
set.seed(123)
companies <- df$permno %>% unique()
number_of_companies <- companies %>% length()
subset_of_companies <- companies %>%
sample(x = ., size = as.integer(number_of_companies*ratio))
return(df %>% filter(permno %in% subset_of_companies))
}
# Feature selection functions --------------------------------------------------
remove_cols_only_zero_and_NA <- function(df, print_removed_cols = F) {
#' @description              Function that removes columns containing only
#'                           zeros and NAs
#'
#' @param df                 Passing a data frame
#' @param print_removed_cols True if user want to print removed columns
#' @return                   Data frame without columns that containing only
#'                           zeros and NAs
cols <- df %>%
apply(MARGIN = 2,
function(x) (sum(x==0, na.rm = T) + sum(is.na(x)))/length(x))
cols <- cols[cols == 1] %>%
as.data.frame() %>%
rownames()
if(print_removed_cols) cat("Columns removed: ", cols, "\n\n")
return (df %>% dplyr::select(-cols))
}
remove_NA <- function(df, ratio, print_removed_cols = F){
#' @description              Function that removes columns containing NAs
#'                           beyond a given ratio
#'
#' @param df                 Passing a data frame
#' @param ratio              Passing a upper limit NA ratio
#' @param print_removed_cols True if user want to print removed columns
#' @return                   Data frame without columns containing NAs
#'                           beyond given ratio
cols <- df %>%
apply(MARGIN = 2,
function(x) sum(is.na(x))/length(x))
cols <- cols[cols >= ratio] %>%
as.data.frame() %>%
rownames()
if(print_removed_cols) cat("Columns removed: ", cols, "\n\n")
return(df %>% dplyr::select(-cols))
}
remove_nzv <- function(df, print_removed_cols = F){
#' @description              Function that removes near zero variance
#'                           columns
#'
#' @param df                 Passing a data frame
#' @param print_removed_cols True if user want to print removed columns
#' @return                   Data frame without columns near zero variance
#'                           columns
rec <- recipe(retx ~ .,
data = df)
cols <- (rec %>%
step_nzv(all_predictors()) %>%
prep(df) %>%
tidy(number = 1))$terms
if(print_removed_cols) cat("Columns removed: ", cols, "\n\n")
return(df %>% dplyr::select(-cols))
}
remove_hcv <- function(df, threshold = 0.9, print_removed_cols = F){
#' @description              Function that removes highly correlated
#'                           features
#'
#' @param df                 Passing a data frame
#' @param treshold           Correlation beneath this threshold
#' @param print_removed_cols True if user want to print removed columns
#' @return                   Data frame without highly correlated features
numeric_cols <- df %>%
lapply(is.numeric) %>%
unlist()
rec <- recipe(retx ~ .,
data = df[numeric_cols])
cols <- (rec %>%
step_corr(all_predictors(),
threshold = threshold) %>%
prep(df[numeric_cols]) %>%
tidy(number = 1))$terms
if(print_removed_cols) cat("Columns removed: ", cols, "\n\n")
return(df %>% dplyr::select(-cols))
}
replace_NA_with_mean <- function(df, print_replaced_cols = F){
#' @description               Function that replaces NA with column means
#'
#' @param df                  Passing a data frame
#' @param print_replaced_cols True if user want to print replaced columns
#' @return                    Data frame NA-replaced column means
na_cols <- df %>%
apply(MARGIN = 2,
function(x) any(is.na(x)))
numeric_cols <- df[na_cols] %>%
lapply(is.numeric) %>%
unlist()
col_means <- df[na_cols] %>%
colMeans(na.rm = T)
col_names <- col_means %>%
names()
for (col in col_names){
df[col] <- df[col][[1]] %>%
replace_na(col_means[col])
}
if(print_replaced_cols) cat("Columns replaced: ", col_names, "\n\n")
return(df)
}
remove_NA_rows <- function(df) {
#' @description Function that removes any rows with one or more NA's
#'
#' @param df    Passing a data frame
#' @return      Data frame NA filtered rows
return(df %>% filter(across(everything(), ~ !is.na(.x))) )
}
perform_train_test_split <- function(df, train_ratio = 0.8) {
#' @description Ensures an equal amount of companies in each set
#'
#' @param df    The dataframe to be split
#' @param ratio Ratio of training data, (validation and test set to equal
#'              length)
#' @return      A list of three data frames: training, validation and
#'              test sets
set.seed(123)
all_companies <- df$permno %>% unique()
train_indices <- sample(1:length(all_companies),
floor(length(all_companies) * train_ratio))
train_companies <- all_companies[train_indices]
test_companies <- all_companies[-train_indices]
train_sample <- df %>% filter(permno %in% train_companies)
test_sample  <- df %>% filter(permno %in% test_companies)
return (list(train_sample, test_sample))
}
find_company_observations <- function(df, minimum_observations) {
#' @description                 Finds companies that have less than a
#'                              minimum amount of observations
#'
#' @param df                    Passing a data frame
#' @param minimum_observations  Passing minimum observation limit
#' @return                      A data frame
all_companies <- df$permno %>%
unique()
df %<>% group_by(permno) %>%
summarise(count = n()) %>%
ungroup() %>%
filter(count < minimum_observations) %>%
arrange(desc(count))
return(df)
}
# Enable parallel processing
num_cores <- detectCores() - 3
cl <- makePSOCKcluster(num_cores) # Use most cores, or specify
registerDoParallel(cl)
expanded_summary  <- function(data, lev = NULL, model = NULL){
#' @description
#'
#' @param data
#' @param lev
#' @param model
a1 <- defaultSummary(data, lev, model)
c1 <- prSummary(data, lev, model)
out <- c(a1, b1, c1)
out
}
# Train Control
train_control <- trainControl(method = "cv",
number = 10,
verboseIter = T,
savePredictions = T,
summaryFunction = defaultSummary)
df_all <- merged %>%
remove_cols_only_zero_and_NA(print_removed_cols = T) %>%
remove_NA(0.2, print_removed_cols = T) %>%
remove_nzv(print_removed_cols = T) %>%
remove_hcv(0.9, print_removed_cols = T) %>%
remove_NA_rows() # Remove rows with NA's
train_test <- perform_train_test_split(df_all,
train_ratio = 0.8)                       # Split into train and test set with seperate sets of companies
train_df_all <- train_test[[1]]
test_df_all <- train_test[[2]]
train_df_all %<>% dplyr::select(-permno) # Remove company numbers from training
low_observation_count_companies <- find_company_observations(test_df_all, 60)
test_df_all %<>% anti_join(low_observation_count_companies)
keras_nn_grid <-expand.grid(size = 62, # According to the geometric pyramid rule (Masters, 1993)
decay= c(0.001, 0),
activation = "relu")
multi_hidden_layer_model <- train(retx ~ .,
data       = train_df_all,
preProcess = c("center", "scale"),
trControl  = train_control,
tuneGrid   = keras_nn_grid,
metric     = "MAE",
verbose = T,
allowParalell = T,
method     = "mlpKerasDecayCost")
Y
install_tensorflow
install_tensorflow()
reticulate::install_miniconda()
keras::install_keras()
keras::install_keras(conda = "miniconda")
reticulate::install_miniconda()
